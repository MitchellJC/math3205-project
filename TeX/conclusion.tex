% Conclusion
We reimplemented a pure MIP and Benders' Decomposition models from~\cite{roshanaei2017propagating}. Models were extended by constructing a new Benders' Cut LBBD4 and by trialling a network model. Implementation was extended by using lazy constraints in Gurobi. Implementations succesfully generated consistent optimal solutions across all models. Implementations generated feasible solutions from observation. Models were able to solve to optimality for only a small patient set size of 20 but were able to scale up to 80 patients when solving to a 1\% gap. We were not able to replicate the efficiency of Benders' Decomposition from the original paper, this was believed to be caused by some sub-optimal implementation used or the difference data generation.  

From our results, the pure MIP model performed the best overall, being the most robust when solving to optimality and being the fastest to solve across all sizes of patient sets when solving to a 1\% gap. The Network model was the least robust when solving to optimality and the slowest when solving to a 1\% gap. Overall, callback implementations performed slightly better than iterative variants.

% Future improvements/work.
Discretizing time further into periods may remedy some of the scaling issues found with all models when solving to optimality, this would sacrifice accuracy for speed, although this can already be done by simply using a larger gap. 

Larger number of patients could be tested to find the limits of the models when solving to a 1\% gap as it was seen that all models were still quite robust up to 80 patients. 

Further algorithmic optimization could be trialled. Caching of sub problems was used to check for identical sub problems but exploratory tests using a more sophisticated caching protocal showed promise, project time constraints and long run-times constrained the collection of more results. The more sophisticated caching methods depend on looking at the sorted set of patients for a given solved sub problem. And the sorted set of patients for the current sub problem. If patient-wise times for the current sub problem are less than or equal to those of a feasible cached sub problem, we know a feasible solution to the current sub problem. Similarly, if the patient-wise time for the current sub problem are greater than or equal to those of an infeasible cached sub problem, we know the current sub problem must be infeasible. The results for this may show great improvement, especially for lazy constraint implementations where similar sub problems are visited often.
